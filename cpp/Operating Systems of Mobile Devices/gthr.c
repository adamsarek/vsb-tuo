#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <sys/time.h>
#include <string.h>

#include "gthr.h"
#include "gthr_struct.h"

struct timeval tv_init, tv_end;
int scheduler = 0;
static int ticketsTotalCount = 0;

// function triggered periodically by timer (SIGALRM)
void gthandle(int sig) {
  gtyield();
}

// initialize first thread as current context
void gtinit(int pScheduler, int priority, int * tickets, int ticketsCount) {
  scheduler = pScheduler;
  
  gtcur = & gttbl[0];			// initialize current thread with thread #0
  gtcur -> st = Running;		// set current to running
  gettimeofday(&tv_init, NULL);
  
  gtcur -> priorityDefault = priority;
  gtcur -> priorityCurrent = priority;

  addTickets(&gtcur -> tickets, tickets, ticketsCount);
  gtcur -> ticketsCount = ticketsCount;

  signal(SIGALRM, gthandle);	// register SIGALRM, signal from timer generated by alarm
}

// exit thread
void __attribute__((noreturn)) gtret(int ret) {
  if (gtcur != & gttbl[0]) {	// if not an initial thread,
    gtcur -> st = Unused;		// set current thread as unused
    gtyield();					// yield and make possible to switch to another thread
    assert(!"reachable");		// this code should never be reachable ... (if yes, returning function on stack was corrupted)
  }
  while (gtyield());			// if initial thread, wait for other to terminate
  exit(ret);
}

// switch from one thread to other
bool gtyield(void) {
  struct gt * p;
  struct gtctx * old, * new;

  resetsig(SIGALRM);			// reset signal

  bool readyThreadFound = false;
  
  switch(scheduler) {
    case 2: {
      bool threadSelected = false;
      int ticket = rand() % ticketsTotalCount;
      int i = 0;

      while(!threadSelected) {
        p = & gttbl[i];
        if(ticket <= p -> tickets[p -> ticketsCount-1]) {
          threadSelected = true;
        }
        else {
          i++;
        }
      }
      break;
    }
    case 1: {
      bool threadSelected = false;
      int priority = MaxPriority;
      p = gtcur;

      while (!threadSelected) {
        if(++p == & gttbl[MaxGThreads]) {
          p = & gttbl[0];
        }
        if(p == gtcur) {
          if(readyThreadFound && priority < MinPriority) {
            priority += 1;
          }
          else {
            return false;
          }
        }
        if(p -> st == Ready) {
          readyThreadFound = true;

          if(p -> priorityCurrent == priority) {
            threadSelected = true;
            p -> priorityCurrent = p -> priorityDefault;
          }
          else if(p -> priorityCurrent > MaxPriority) {
            p -> priorityCurrent -= 1;
          }
        }
      }
      break;
    }
    default: {
      p = gtcur;
      while (p -> st != Ready) {
        if (++p == & gttbl[MaxGThreads])
          p = & gttbl[0];
        if (p == gtcur)
          return false;
      }
      break;
    }
  }
  
  if (gtcur -> st != Unused)			// switch current to Ready and new thread found in previous loop to Running
  {
    gettimeofday(&tv_end, NULL);
    
    gtcur -> st = Ready;
    long runtime = (tv_end.tv_sec - tv_init.tv_sec) * 1000000 + (tv_end.tv_usec - tv_init.tv_usec);
    if(gtcur -> runtimeCount > 0) {
      gtcur -> runtime += runtime;
      gtcur -> runtimeCount += 1;
      if(runtime < gtcur -> runtimeMin) { gtcur -> runtimeMin = runtime; }
      if(runtime > gtcur -> runtimeMax) { gtcur -> runtimeMax = runtime; }
      gtcur -> runtimeAvg = gtcur -> runtime / (double)gtcur -> runtimeCount; 
    }
    else {
      gtcur -> runtime = runtime;
      gtcur -> runtimeCount = 1;
      gtcur -> runtimeMin = runtime;
      gtcur -> runtimeMax = runtime;
      gtcur -> runtimeAvg = runtime;
    }

    gettimeofday(&tv_init, NULL);
  }
  p -> st = Running;
  old = & gtcur -> ctx;					// prepare pointers to context of current (will become old) 
  new = & p -> ctx;						// and new to new thread found in previous loop
  gtcur = p;							// switch current indicator to new thread
  gtswtch(old, new);					// perform context switch (assembly in gtswtch.S)
  return true;
}

// return function for terminating thread
void gtstop(void) {
  gtret(0);
}

// create new thread by providing pointer to function that will act like "run" method
int gtgo(void( * f)(void), int priority, int * tickets, int ticketsCount) {
  char * stack;
  struct gt * p;

  for (p = & gttbl[0];; p++)			// find an empty slot
    if (p == & gttbl[MaxGThreads])		// if we have reached the end, gttbl is full and we cannot create a new thread
      return -1;
    else if (p -> st == Unused)
    break;								// new slot was found

  stack = malloc(StackSize);			// allocate memory for stack of newly created thread
  if (!stack)
    return -1;

  *(uint64_t * ) & stack[StackSize - 8] = (uint64_t) gtstop;	//	put into the stack returning function gtstop in case function calls return
  *(uint64_t * ) & stack[StackSize - 16] = (uint64_t) f;		//  put provided function as a main "run" function
  p -> ctx.rsp = (uint64_t) & stack[StackSize - 16];			//  set stack pointer
  p -> st = Ready;												//  set state
  
  p -> priorityDefault = priority;
  p -> priorityCurrent = priority;

  addTickets(&p -> tickets, tickets, ticketsCount);
  p -> ticketsCount = ticketsCount;

  return 0;
}

void resetsig(int sig) {
  if (sig == SIGALRM) {
    alarm(0);			// Clear pending alarms if any
  }

  sigset_t set;				// Create signal set
  sigemptyset( & set);		// Clear it
  sigaddset( & set, sig);	// Set signal (we use SIGALRM)

  sigprocmask(SIG_UNBLOCK, & set, NULL);	// Fetch and change the signal mask

  if (sig == SIGALRM) {
    // Generate alarms
    ualarm(500, 500);		// Schedule signal after given number of microseconds
  }
}

int uninterruptibleNanoSleep(time_t sec, long nanosec) {
  struct timespec req;
  req.tv_sec = sec;
  req.tv_nsec = nanosec;

  do {
    if (0 != nanosleep( & req, & req)) {
      if (errno != EINTR)
        return -1;
    } else {
      break;
    }
  } while (req.tv_sec > 0 || req.tv_nsec > 0);
  return 0; /* Return success */
}

void addTickets(int ** ticketsTo, int * ticketsFrom, int ticketsCount) {
  *ticketsTo = calloc(ticketsCount, sizeof(int));
  for(int i = 0; i < ticketsCount; i++) {
    (*ticketsTo)[i] = ticketsFrom[i];
  }
  ticketsTotalCount += ticketsCount;
}

void printStats() {
  long runtime = 0;
  long runtimeCount = 0;
  long runtimeMin = 0;
  long runtimeMax = 0;
  long runtimeAvg = 0;
  int ticketsCount = 0;

  if(MaxGThreads > 0) {
    struct gt * p = &gttbl[0];

    // Overall stats
    runtime += p -> runtime;
    runtimeCount += p -> runtimeCount;
    runtimeMin = p -> runtimeMin;
    runtimeMax = p -> runtimeMax;
    runtimeAvg = p -> runtimeAvg;
    ticketsCount += p -> ticketsCount;

    for(int i = 1; i < MaxGThreads; i++) {
      struct gt * p = &gttbl[i];

      // Overall stats
      runtime += p -> runtime;
      runtimeCount += p -> runtimeCount;
      if(p -> runtimeMin < runtimeMin) { runtimeMin = p -> runtimeMin; }
      if(p -> runtimeMax > runtimeMax) { runtimeMax = p -> runtimeMax; }
      runtimeAvg = runtime / (double)runtimeCount;
      ticketsCount += p -> ticketsCount;
    }

    // Print stats
    const char * schedulerName = (
      scheduler == 2 ? "LS (lottery scheduling)" : (
      scheduler == 1 ? "PRI (priority scheduling)" :
                       "RR (round robin)"));
    printf("\n");
    printf("+---------------------------------------------------------------------------------------------------------+\n");
    printf("| Scheduler: %-25s                                                                    |\n", schedulerName);
    printf("+--------------+-----------------------------------------------+-----------+-----------+------------------+\n");
    printf("| Thread       | Running time (μs)                             | Wait (μs) | Priority  | Lottery          |\n");
    printf("+----+---------+-----+---------+----------+-----------+--------+-----------+-----+-----+---------+--------+\n");
    printf("|  # | State   | Min |     Avg |      Max |     Total |      %% |     Total | Cur | Def | Tickets |      %% |\n");
    printf("+----+---------+-----+---------+----------+-----------+--------+-----------+-----+-----+---------+--------+\n");
    for(int i = 0; i < MaxGThreads; i++) {
      struct gt * p = &gttbl[i];
      
      char state[7];
      switch(p -> st) {
        case Unused: {
          char st[] = "Unused";
          memcpy(state, st, sizeof(st));
          break;
        }
        case Running: {
          char st[] = "Running";
          memcpy(state, st, sizeof(st));
          break;
        }
        case Ready: {
          char st[] = "Ready";
          memcpy(state, st, sizeof(st));
          break;
        }
      }

      printf("| %2i | %-7s | %3ld | %7ld | %8ld | %9ld | %6.2f | %9ld | %3i | %3i | %7i | %6.2f |\n",
        i,
        state,
        p -> runtimeMin,
        p -> runtimeAvg,
        p -> runtimeMax,
        p -> runtime,
        100 * p -> runtime / (double)runtime,
        runtime - p -> runtime,
        p -> priorityCurrent,
        p -> priorityDefault,
        p -> ticketsCount,
        100 * p -> ticketsCount / (double)ticketsCount);
    }
    printf("+----+---------+-----+---------+----------+-----------+--------+-----------+-----+-----+---------+--------+\n");
    printf("| %2i | %-7s | %3ld | %7ld | %8ld | %9ld | %6.2f | %9s | %3s | %3s | %7i | %6.2f |\n",
      MaxGThreads,
      "",
      runtimeMin,
      runtimeAvg,
      runtimeMax,
      runtime,
      100.0,
      "",
      "",
      "",
      ticketsCount,
      100.0);
    printf("+----+---------+-----+---------+----------+-----------+--------+-----------+-----+-----+---------+--------+\n");
  }
  else {
    printf("+---------------------------------------------------------------------------------------------------------+\n");
    printf("|                                          There are no threads!                                          |\n");
    printf("+---------------------------------------------------------------------------------------------------------+\n");
  }
}